# 알고리즘

- **간단한 정의 : 문제를 해결하는 방법**

  - **효율성** : 수많은 문제 해결 방법 중에 가장 효율적인 것

  - **단계적** : 해결 방법을 한 번에 설명하기 보다는 단계별로, 체계적으로 설명되어야 하기 때문

- 배워야할 것

  - **DFS / BFS , 문자열 , 단순구현 , 완전탐색 , 해시**

## 컴퓨터 알고리즘의 정의와 의미

- 컴퓨터 언어

  - 컴퓨터가 대화하기 위해서 사용하는 언어

- **컴퓨터 알고리즘**

  - 컴퓨터를 이용하여 주어진 문제를 풀기 위한 방법이나 절차

- 컴퓨터 프로그램

  - 컴퓨터가 특정 작업을 수행하기 위해 짜여진 명령의 순서

## 컴퓨터 알고리즘을 설명하기 위한 4단계

1. 문제 정의 (Problem definition)

- 해결하고자 하는 문제는 무엇인가?

- 입력과 출력의 형태로 정의될 수 있는가?

- 컴퓨터가 수행할 수 있는 형태로 전환이 가능한가?

2. 알고리즘 설명 (Algorithm description)

- 컴퓨터가 수행해야 할 내용을 하나씩 차례대로 정의한 과정

3. 정확성 증명 (Correctness proof)

- 과정대로 수행하면 출력으로 항상 올바른 답을 내보내는가?

- 잘못된 답을 내보내는 경우는 없는가?

- 올바른 출력을 내보내고 정상적으로 종료되는가?

4. 성능 분석 (Performance analysis)

- 사용 공간 (Space consumption)

- 수행 시간 (Running time)

  - 특정 기계에서 수행시간을 측정하는 것은 공정하지 않다. 따라서 조건이 동일한 특정 기계에서 모든 알고리즘의 수행시간을 측정해야 하는데, 이는 **현실적으로 불가능하다.**

  - 그러므로 **수행연산의 횟수를 비교하는 방식으로 성능을 분석한다.**

  - 수행 시간은 **입력으로 크기가 커질수록 시간이 많이 걸린다.**

    - 10개의 키를 정렬하는 시간이 100개의 키를 정렬하는 시간보다 짧다.

  - 따라서 수행 시간은 입력 크기 n에 대한 함수로 표현한다.

    - 예를 들면, T(n) 또한 n에 대한 다항식에서 최고차 항 만을 고려한다.

  - 기본이 되는 연산 (성능 분석의 비교 대상)

    - 산술 연산 (Arithmetic Calculation)

      - Add, Multiply, Exponent, Modular ... / 곱하기, 지수승이 보통 많이 쓰인다.

    - 데이터 입출력 (Data Movement)

      - Copy, Move, Save, Load ...

    - 제어 연산 (Access Control)

      - If, While, Register ...

- 점근적 표기법

  - 빅오 표기 : 그래프상에서 주어진 함수가 기준이 되는 함수보다 아래에 존재한다. g(n)을 함수f(n)의 **점근적 상한(asymptotic upper bound)** 이라 한다.

    - 주어진 함수보다 항상 위쪽 기준의 함수가 존재해서 아무리 함수가 느려진다 하더라도 주어진 기준 함수보다는 항상 빠르다는 것을 보장한다.

  - 오메가 표기 : g(n)을 함수f(n)의 **점근적 하한(asymptotic lower bound)** 이라 한다.

    - 빅오의 반대이다. 아무리 빨라진다 하더라도 주어진 하한보다는 더 이상 빨라질 수 없다.

  - 세타 표기 : 빅오와 오메가를 같이 사용한다. **점근적 상한 및 하한(asymptotic tight bound)**

    - 주어진 함수가 가장 정확하게 분석된 것

## 정렬 문제의 정의 (Sorting problem)

- 입력과 출력으로 명확하게 정의해 주어야 한다.

  - 입력 : n개의 숫자들의 배열

  - 출력 : 입력한 숫자의 배열이 조건을 만족하도록 다시 나열한 결과

- 순서에 따라서 오름차순, 내림차순으로 나뉘어진다.

### 선택 정렬 알고리즘 (Selection sort)

- 선택정렬은 무엇인가? : 선택하여 정렬하는 알고리즘

- 무엇을 선택할 것인가?

  - 최소값 선택 정렬 (Min-Selection sort) : 가장 작은 값을 선택 (오름차순)

    1. 정렬되지 않은 숫자 중에 가장 작은 숫자를 선택한다.

    2. 선택한 숫자를 정렬되지 않은 숫자들 중 첫 번째 숫자와 자리를 바꾸면 선택된 숫자는 정렬된 것이다.

    3. 모든 숫자를 옮길 때까지 1, 2번 과정을 반복한다.

  - 최대값 선택 정렬 (Max-Selection sort) : 가장 큰 값을 선택 (내림차순)

- 정확성 증명

  - 수학적 귀납법을 이용한다.

  - i번째 선택한 숫자가 i번째로 작은 (혹은 큰) 숫자인지 증명한다.

- 성능 분석

  - 최선/최악의 경우 수행시간 & 공간

  - 입력받은 숫자들의 배열이 어떤 형태이면 최선/최악의 경우가 되는가?

    - 선택정렬에서는 최선/최악의 경우가 없다. (항상 남아있는 값들을 전부 비교하기 때문이다.)

## 해시 (Hash)

- 해시의 개념 : **key : value 형태**를 가지는 하나의 자료구조이다.

  - ex) 전화번호부

  - 검색창에 이름을 검색하면 친구의 전화번호가 나온다.

  - 이름 = key (무언가를 찾기 위한 검색어) / 전화번호 = value (그 검색어로 나온 결과)

- 해시가 없을 때의 시절에는 배열을 처음부터 끝까지 일일히 찾아봐야 했다.

- 해시는 배열과 달리 string 타입이나 다른 어떤 데이터형을 기반으로 자료구조를 접근하고 데이터를 관리할 수 있게 해준다. **(해시는 모든 데이터 타입으로 접근이 가능하다)**

- 어떤 문제에서 해시를 써야 할까?

  - **string을 기반으로 정보를 기록하고 관리해야 할 때**

총 정리

1. 해시는 전화번호부와 같다.

   - 정수가 아닌 key를 가질 수 있어 배열로 담을 수 없는 정보를 담을 수 있게 된다.

2. 대부분 그 key가 string이다.
